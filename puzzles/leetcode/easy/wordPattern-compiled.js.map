{"version":3,"sources":["wordPattern.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAmBA,CAAC,SAAS,IAAI,GAAE;AACZ,gBAAY,CAAC;;AAEb,QAAI,OAAO,GAAG,MAAM,CAAC;AACrB,QAAI,GAAG,GAAG,iBAAiB,CAAC;;AAE5B,aAAS,MAAM,CAAC,GAAG,EAAC;AAChB,YAAI,OAAO,GAAG,EAAE,CAAC;AACjB,YAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC3B,aAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EACpC;AACI,mBAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAC7B;;AAED,eAAO,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAC3B;;AAED,aAAS,UAAU,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE;AACpC,eAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC;KACxC;;AAED,aAAS,aAAa,CAAC,GAAG,EAAC;AACvB,eAAO,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;KACjC;;AAED,aAAS,QAAQ,CAAC,GAAG,EAAC;AAClB,YAAI,GAAG,GAAG,EAAE,CAAC;AACb,YAAI,OAAO,GAAG,EAAE,CAAC;AACjB,YAAI,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AAC5B,YAAI,aAAa,GAAG,CAAC,CAAC;;AAEtB,aAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAC;;AAEnC,gBAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EACvB;AACI,uBAAO,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;aAC9B,MACG;AACA,mBAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;AAChC,uBAAO,IAAI,aAAa,CAAC;AACzB,6BAAa,EAAE,CAAA;aAClB;SACJ;;AAED,eAAO,OAAO,CAAC;KAElB;;AAID,WAAO,CAAC,GAAG,CAAC,WAAW,GAAG,OAAO,CAAC,CAAC;AACnC,WAAO,CAAC,GAAG,CAAC,kBAAkB,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;;AAGpD,WAAO,CAAC,GAAG,CAAC,kBAAkB,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9C,WAAO,CAAC,GAAG,CAAC,iBAAiB,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;AAEvD,WAAO,CAAC,GAAG,CAAC,SAAS,IAAI,QAAQ,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA,AAAC,CAAC,CAAC;CAE1E,CAAA,EAAG,CAAC","file":"wordPattern-compiled.js","sourcesContent":["/*\n\n Given a pattern and a string str, find if str follows the same pattern.\n\n Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\n\n Examples:\n pattern = \"abba\", str = \"dog cat cat dog\" should return true.\n pattern = \"abba\", str = \"dog cat cat fish\" should return false.\n pattern = \"aaaa\", str = \"dog cat cat dog\" should return false.\n pattern = \"abba\", str = \"dog dog dog dog\" should return false.\n\n Notes:\n You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\n\n */\n\n\n\n(function iife(){\n    'use strict';\n\n    let pattern = \"abba\";\n    let str = \"dog cat cat dog\";\n\n    function reduce(str){\n        let letters = [];\n        let words = str.split(' ');\n        for(let i = 0; i < words.length; i++)\n        {\n            letters.push(words[i][0]);\n        }\n\n        return letters.join('');\n    }\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    function uniqueLetters(str){\n        return str.filter(onlyUnique);\n    }\n\n    function numerise(str){\n        let map = [];\n        let numbers = '';\n        let letters = str.split('');\n        let currentNumber = 0;\n\n        for(let i = 0; i < letters.length; i++){\n\n            if(map[letters[i]] > -1)\n            {\n                numbers += map[letters[i]];\n            }\n            else{\n                map[letters[i]] = currentNumber;\n                numbers += currentNumber;\n                currentNumber++\n            }\n        }\n\n        return numbers;\n\n    }\n\n\n\n    console.log('Pattern: ' + pattern);\n    console.log('Pattern Digits: ' + numerise(pattern));\n\n\n    console.log('Output Letters: ' + reduce(str));\n    console.log('Output Digits: ' + numerise(reduce(str)));\n\n    console.log('Equal: ' + (numerise(pattern) === numerise(reduce(str))));\n\n})();"]}